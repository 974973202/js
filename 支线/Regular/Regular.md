[正则表达式]https://juejin.im/post/5965943ff265da6c30653879
### 正则表达式(Regular Expression)
> 其实就是一门工具，目的是为了字符串模式匹配，从而实现搜索和替换功能
- 特殊字符
> 匹配区间 | 正则表达式 | 记忆方式
> -|-|-
> 换行符 | \n | new line
> 换页符 | \f | form feed
> 回车符 | \r | return
> 空白符 | \s | space
> 制表符 | \t | tab
> 垂直制表符 | \v | vertical tab
> 回退符 | [\b] | backspace,之所以使用[]符号是避免和\b重复

> 除了换行符之外的任何字符 | . | 句号,除了句子结束符
> -|-|-
> 单个数字, [0-9] | \d | digit
> 除了[0-9] | \D | not digit
> 包括下划线在内的单个字符，[A-Za-z0-9_] | \w | word
> 非单字字符 | \W | not word
> 匹配空白字符,包括空格、制表符、换页符和换行符 | \s | space
> 匹配非空白字符 | \S | not space

- 元字符 **?** 代表了匹配一个字符或0个字符。设想一下，如果你要匹配color和colour这
两个单词，就需要同时保证u这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样
的：/colou?r/ (0|1)

- 元字符 **\*** 用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串 (>=0)

- 元字符 **+** 适用于要匹配同个字符出现1次或多次的情况 (>=1)

- 元字符 **{** 和 **}** 用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就
使用/a{3}/这个正则，或者说'a'我想匹配至少两次就是用/a{2,}/这个正则
> - {x}: x次
> - {min, max}： 介于min次到max次之间
> - {min, }: 至少min次
> - {0, max}： 至多max次

> 边界和标志 | 正则表达式 | 记忆方式
> -|-|-
> 单词边界 | \b | boundary
> 非单词边界 | \B | not boundary
> 字符串开头 | ^ | 小头尖尖那么大个
> 字符串结尾 | $ | 终结者，美国科幻电影，美元符$
> 多行模式 | m标志 | multiple of lines
> 忽略大小写 | i标志 | ignore case, case-insensitive
> 全局模式 | g标志 | global

### 分组
```
所有以 ( 和 ) 元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达
式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组
是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式
```

### 回溯引用
- 比如要写一个正则支持匹配如下三种格式
```
2016-06-12
2016/06/12
2016.06.12

var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";
var regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/;
也匹配"2016-06/12"这样的数据

假设我们想要求分割符前后一致怎么办? 此时需要使用反向引用
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;
```
> 注意里面的\1，表示的引用之前的那个分组(-|\/|\.)。不管它匹配到什么（比如
-），\1都匹配那个同样的具体某个字符

```
所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你
可以把它想象成是变量，回溯引用的语法像\1,\2,....,其中\1表示引用的第一个子表达式，\2
表示引用的第二个子表达式，以此类推。而\0则表示整个表达式
```

### 前向查找
```
前向查找(lookahead)是用来限制后缀的。凡是以(?=regex)包含的子表达式在匹配过程中都会
用来限制前面的表达式的匹配。例如happy happily这两个单词，我想获得以happ开头的副
词，那么就可以使用happ(?=ily)来匹配。如果我想过滤所有以happ开头的副词，那么也可以采
用负前向查找的正则happ(?!ily)，就会匹配到happy单词的happ前缀
```

### 后向查找
```
介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找
(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规
则的字串。举个简单的例子： apple和people都包含ple这个后缀，那么如果我只想找到apple
的ple，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定ple这个单词了
```
```
/(?<=app)ple/
```
```
其中(?<=regex)的语法就是我们这里要介绍的后向查找。regex指代的子表达式会作为限制项进
行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用(?<!regex) 语
法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在
上面的例子中，如果想要查找apple的ple也可以这么写成/(?<!peo)ple。
需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用
到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转
回来。看一个简单的例子
```
```
// 比如我想替换apple的ple为ply
var str = 'apple people';
str.split('').reverse().join('').replace(/elp(?=pa)/, 'ylp').split('').reverse().join('');
```

> 回溯查找 | 正则 | 记忆方式
> -|-|-
> 引用 | \0,\1,\2 和 $0, $1, $2 | 转义+数字
> 非捕获组 | (?:) | 引用表达式(()), 本身不被消费(?),引用(:)
> 前向查找 | (?=) | 引用子表达式(())，本身不被消费(?), 正向的查找(=)
> 前向负查找 | (?!) | 引用子表达式(())，本身不被消费(?), 负向的查找(!)
> 后向查找 | (?<=) | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=)
> 后向负查找 | (?<!) | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!)

### 逻辑处理
> - 计算机科学就是一门包含逻辑的科学。
> - 让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。
> - 在正则里面，默认的正则规则都是与的关系所以这里不讨论。
> - 而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。
> - 在字符匹配的时候，需要使用^这个元字符。
> - 在这里要着重记忆一下：只有在 **[** 和 **]**内部使用的^才表示非的关系。
> - 子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式(?!regex)或后向负查找子表达式(?<!regex)。
> - 或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用(a|b)这样的子表达式。

> 逻辑关系 | 正则元字符
> -|-
> 与 | 无
> 非 | [^regex]和!
> 或 | |

- 匹配html节点id
```
var regex = /id="[^"]*"/
// var regex = /id=".*?"/
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]); 
// => id="container"
```

- 三位前面加，
```
var result = "12345678".replace(/(?=\w{3}$)/g, ',')
console.log(result); 
// => "12345,678"
```

- 所有三位前加，
```
var result = "12345678".replace(/(?=(\w{3})+$)/g, ',')
console.log(result); 
// => "12,345,678"
```

- 偶数情况
```js
var string1 = "12345678",
string2 = "123456789";
reg = /(?!^)(?=(\d{3})+$)/g;
var result = string1.replace(reg, ',')
console.log(result); 
// => "12,345,678"
result = string2.replace(reg, ',');
console.log(result); 
// => "123,456,789"
// toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,'); // 千分位切保留小数点后两位  398,944.02
```

- 其他形式
```
var string = "12345678 123456789",
reg = /(?!\b)(?=(\d{3})+\b)/g;
var result = string.replace(reg, ',')
console.log(result); 
// => "12,345,678 123,456,789"
```

- 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符
```
var reg = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/
```
- 加强
> 1. 同时包含数字和小写字母
> 2. 同时包含数字和大写字母
> 3. 同时包含小写字母和大写字母
> 4. 同时包含数字、小写字母和大写字母
```
var reg = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/;
var reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;
```

- 把yyyy-mm-dd格式，替换成mm/dd/yyyy
```
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result); 
// => "06/12/2017"
```
> 其中replace中的，第二个参数里用$1、$2、$3指代相应的分组。等价于如下的形式：
```
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function() {
	return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result); 
// => "06/12/2017"
```
> 也等价于：
```
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function(match, year, month, day) {
	return month + "/" + day + "/" + year;
});
console.log(result); 
// => "06/12/2017"
```

- 将每个单词的首字母转换为大写
```
function titleize(str) {
	return str.toLowerCase().replace(/(?:^|\s)\w/g, function(c) {
		return c.toUpperCase();
	});
}
console.log( titleize('my name is epeli') ); 
// => "My Name Is Epeli"
```

- 匹配成对标签
```js
要求匹配：
<title>regular expression</title>
<p>laoyao bye bye</p>
var regex = /<([^>]+)>[\d\D]*<\/\1>/;
```

```js
"17201234567".replace(/(\d{3})\d{4}(\d{4})/, '$1****$2'); // 172****4567
```

- 匹配 {} 不匹配 ${} #{}
```js
var regex = /(?<![#$]){[^{}]+}/g
```

- 匹配多个<code>xx</code>标签之间的内容
- 包含code    ---   var regex = /<code[^>]*>(?:(?!<\/code>)[\s\S])*<\/code>/gi;
- 不包含code  ---   var regex = /(?<=<code[^>]*>)(?:(?!<\/code>)[\s\S])*(?=<\/code>)/gi;