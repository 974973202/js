[http]https://juejin.im/post/5e015a60e51d45583d426a15
[get和post]https://juejin.im/post/59fc04ecf265da4317697f26
[三次握手和四次挥手]https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73

### 为什么握手三次挥手四次
　这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送

http1.0-http3.0 做了什么优化
然后https和http区别，加密解密
然后常见的浏览器攻击

### HTTP1.0 和 HTTP1.1的一些区别
- 缓存处理
> 在**HTTP1.0**中主要使用header里的If-Modified-Since,Expires来做为缓存判断
的标准，**HTTP1.1**则引入了更多的缓存控制策略例如Entity tag，
If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控
制缓存策略
- 带宽优化及网络连接的使用
> HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，
而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引
入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial 
Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
- 错误通知的管理
> 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与
资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除
- Host头处理
> 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL
并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器
上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地
址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host
头域会报告一个错误（400 Bad Request）
- 长连接
> HTTP 1.1支持长连接（PersistentConnection）和请求的流水线
（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立
和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一
定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

### HTTPS与HTTP的一些区别
- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之
上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者
是443
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题

### HTTPS请求加密的过程
### HTTPS的加密解密的过程

### HTTP2.0和SPDY的区别
- HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
- HTTP2.0 消息头的压缩算法采用 [HPACK]: http://http2.github.io/http2-spec/compression.html
SPDY 采用的 [DEFLATE]: http://zh.wikipedia.org/wiki/DEFLATE

### HTTP2.0和HTTP1.X相比的新特性
- 新的二进制格式
> HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现
形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组
合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
- 多路复用
> 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一
个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在
一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面
- header压缩
> HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder
来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免
了重复header的传输，又减小了需要传输的大小
- 服务端推送
> server push功能 服务端推送能把客户端所需要的资源伴随着index.html一起发
送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操
作，所以静态资源通过服务端推送的方式可以极大地提升速度

### HTTP2.0和HTTP3.0的区别
- HTTP2.0虽然解决了应⽤层⾯的队头阻塞问题，当系统达到了2%的丢包率时，HTTP/1.1的传输效率反⽽⽐HTTP/2表现得更好，HTTP3.0是对UDP的优化

### HTTP 缓存
> 缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓
存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓
存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓
存协商。

- 强缓存
> Expires(HTTP1.0)：Exprires的值为服务端返回的数据到期时间。当再次请求时
的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时
间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产
物，故现在大多数使用Cache-Control替代。
> **缺点**：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致
命中缓存产生偏差。
1. Pragma(HTTP1.0)：HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓
存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字
段的优先级会更高。服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和刷
新(F5)类似。
2. Cache-Control(HTTP1.1)：有很多属性，不同的属性代表的意义也不同：
3. private：客户端可以缓存
4. public：客户端和代理服务器都可以缓存
5. max-age=t：缓存内容将在t秒后失效
6. no-cache：需要使用协商缓存来验证缓存数据
7. no-store：所有内容都不会缓存
> 请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是
可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内
容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 
Expires，会优先处理 max-age 指令。命中强缓存的表现形式：Firefox浏览器表
现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)
或是200 OK (from memory cache)。

- 协商缓存
> 协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器
会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，
客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回
304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。
1. Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。
2. if-Modified-Since：浏览器再次请求服务器的时候，请求头会包含此字段，后
面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回
304和响应报文头，浏览器只需要从缓存中获取信息即可。
> 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK
> 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified
3. if-Unmodified-Since: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。
> 如果没有被修改：则开始`继续'传送文件，服务器返回: 200 OK
> 如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理
错误)
这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资
源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而
返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个
问题，HTTP1.1推出了Etag。
5. Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一
标识（生成规则由服务器决定）
6. If-Match：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断
文件是否有新的修改
7. If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后
面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请
求资源的唯一标识进行对比。
> 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。
> 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。
返回状态码304.
但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资
源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。
> 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求
了，直接去缓存拿（最快）
> F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览
器就胆胆襟襟的发送一个请求带上If-Modify-since
> Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求
个完整的资源文件下来。于是客户端就完成了强行更新的操作

- 缓存场景
> 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可
能需要选择特殊的缓存策略
> 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资
源不需要缓存
> 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使
用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
> 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略
缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件