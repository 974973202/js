JavaScript V8 Engine

 
![JS Engine 内部的工作流程](./JavaScript%20Engine.jpg)
上图就是 JS Engine 内部的工作流程。我们输入的代码将通过以下阶段，

 

Parser
AST
Interpreter 生成 ByteCode
Profiler
Compiler 生成优化后的代码
 

别被上面的流程给唬住了，在几分钟后您将了解它们是协同运作的。

### Interpreter（解释）和 Compiler（编译）的区别

通常，将代码转换成机器可读语言的方法有两种

1. Interpreter 逐行读取代码并立即执行。
2. Compiler 读取您的整个代码，进行一些优化，然后生成优化后的代码。

让我们来看下面这个例子。
```js
function add(a, b) { 
    return a+b
}
for (let i = 0; i < 1000; i++) {
    add(1 + 1)
}
// 上面的示例循环调用了 add 函数1000次，该函数将两个数字相加并返回总和。
```

Interpreter 接收上面的代码后，它将逐行读取并立即执行代码，直到循环结束。它的工作仅仅是实时地将代码转换为我们的计算机可以理解的内容。

如果这段代码接受者是 Compiler，它会先完整地读取整个程序，对我们要执行的代码进行分析，并生成电脑可以读懂的机器语言。过程如同获取 X（我们的JS文件）并生成 Y（机器语言）一样。如果我们使用 Interpreter 执行 Y，则会获得与执行 X 相同的结果。

ByteCode 只是中间码，计算机仍需要对其进行翻译才能执行。

Interpreter 和 Compiler 都将源代码转换为机器语言，它们唯一的区别在于转换的过程不尽相同。

**Interpreter 逐行将源代码转换为等效的机器代码。**
**Compiler 在一开始就将所有源代码转换为机器代码。**

Babel 实际上是一个 JS版的Compiler ，它可以接收您编写的新版本 JS 代码并向下编译为与浏览器兼容的 JS 代码（旧版本的 JS 代码）。

### Interpreter（解释）和 Compiler（编译） 的优缺点

Interpreter 的优点是无需等待编译即可立即执行代码。这对在浏览器中运行 JS 提供了极大的便利，因为所有用户都不想浪费时间在等待代码编译这件事上。但是，当有大量的 JS 代码需要执行时会运行地比较慢。
在同样的情况下，Compiler 可以通过用2代替循环（因为 add 函数每次都是执行1 + 1）来进行一些优化。Compiler 最终给出的优化代码可以在更短的时间内执行完成。

综上所述，Interpreter 可以立即开始执行代码，但不会进行优化。Compiler 虽然需要花费一些时间来编译代码，但是会生成对执行时更优的代码。

好的，Interpreter 和 Compiler 必要知识我们已经了解了。现在让我们回到主题——JS 引擎。

### JIT(Just In Time) Compiler即时编译
因此，考虑到**编译器和解释器**的优缺点，如果我们同时利用两者的优点，该怎么办？这就是 **JIT(Just In Time) Compiler即时编译** 的用武之地。它是 Interpreter 和 Compiler 的结合，现在大多数浏览器都在更快，更高效地实现此功能。同时 V8 引擎也使用此功能。

- 一般来说，为了使你的代码能够执行，编程语言需要被转化为机器代码。对于如何以及何时发生这种转换，有几种方法。
- 最常见的转换代码的方法是进行超前编译。它的工作原理：在编译阶段，代码在程序执行之前就被转化为机器代码了。许多编程语言都采用这种方法，如C++、Java 和其他语言。
- 在表格的另一边，是解释型：每一行代码都将在运行时执行。这种方法通常被动态类型语言（如 JavaScript 和 Python）采用，因为在执行之前不能知道确切的类型。
- 因为提前编译可以一起评估所有代码，它可以提供更好的优化并最终生成更高性能的代码。另一方面，解释型语言更容易实现，但它通常比提前编译慢。
- 为了更快、更有效地为动态语言转换代码，创建了一种称为即时（JIT）编译的新方法。它最好地结合了解释和编译

### JavaScript V8 Engine

在这个过程中，

Parser 是一种通过各种 JavaScript 关键字来识别，分析和分类程序各个部分的解析器。它可以区分代码是一个方法还是一个变量。

然后，AST(抽象语法树) 基于 Parser 的分类构造树状结构。您可以使用 AST Explorer 查看该树的结构。

随后将 AST 提供给 Interpreter 生成 ByteCode。如上文所述，ByteCode 不是最底层的代码，但可以被执行。在此阶段，浏览器借助 V8 引擎执行 ByteCode 进行工作，因此用户无需等待。

同时，Profiler 将查找可以被优化的代码，然后将它们传递给 Compiler。Compiler 生成优化代码的同时，浏览器暂时用 ByteCode 执行操作。并且，一旦 Compiler 生成了优化代码，优化代码则将完全替换掉 临时的 ByteCode。

通过这种方式，我们可以充分利用 Interpreter 和 Compiler 的优点。Interpreter 执行代码的同时，Profiler 寻找可以被优化的代码，Compiler 则创建优化的代码。然后，将 ByteCode 码替换为优化后的较为底层的代码，例如机器代码。

这仅意味着性能将在逐渐提高，同时不会有阻塞执行的时间。

关于 ByteCode

作为机器代码，ByteCode 不能被所有计算机理解及执行。它仍然需要像虚拟机或像 Javascript V8 引擎这样的中间件才能将其转换为机器可读的语言。这就是为什么我们的浏览器可以在上述5个阶段中借助 JavaScript 引擎在 Interpreter 中执行 ByteCode 的原因。

所以您可以会有另一个问题,

JavaScript 是一门解释型语言吗?

JavaScript 是但不完全是一门解释型语言。Brendan Eich 最初是在 JavaScript 的早期阶段创建 JavaScript 引擎 “ SpiderMonkey” 的。该引擎有一个 Interpreter 来告诉浏览器该怎么执行代码。但是现在我们的引擎不仅包括了 Interpreter，还有 Compiler。我们的代码不仅可以被转换成 ByteCode，还可以被编译输出优化后的代码。因此，**从技术上讲，这完全取决于引擎是如何实现的**。

### V8是如何执行JavaScript代码的
作为JavaScript的主流虚拟机，V8是如何编译执行JavaScript代码的呢？它采用的是我们上面介绍的解释执行、编译执行中的哪一种呢？
`解释执行的启动速度快，但是执行速度比较慢，而编译执行的启动速度慢，但是执行速度比较快，所以为了权衡两种方法各自的优缺点，V8采用的是两种方法结合的方式进行编译执行JavaScript代码`

### V8执行JavaScript代码流程
- V8在启动执行JavaScript代码之前，它需要初始化好执行环境，这些环境包括：堆空间、栈空间、全局执行上下文、全局作用域、循环系统♻️、内置函数等，这些内容都是在JavaScript执行过程中需要使用到的。
- 在初始化完执行环境后，就可以向V8提交需要执行的JavaScript代码了。
- V8在接收到JavaScript代码后，并不会立即执行，因为V8并不能直接理解JavaScript代码的含义，这对于它来说只不过就是一段字符串而已。它需要将代码结构化生成抽象语法树（AST），在生成抽象语法树的同时，V8还会生成相应的作用域。
- 有了AST和作用域后，就可以生成字节码了，字节码是介于AST和机器代码之间的中间代码。
- 生成字节码后，解释器就会按照顺序解释执行字节码，并输出执行结果。
- 解释器在执行字节码的过程中，如果发现某段代码被`多次重复`执行，那么这段代码就会被标记成`热点代码`。
- 当某段代码被标记成热点代码后，V8就会将这段代码交给优化编辑器，优化编辑器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码进行优化操作，优化后的二进制机器代码的执行效率就会大幅提升。

- V8采用了一种权衡策略，在启动时采用解释执行的策略，但是如果某段代码的执行频率超过某个值，V8就会采用优化编译器将其编译成执行效率更高的机器代码