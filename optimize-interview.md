### 首屏加载优化
- Vue-Router路由懒加载（利用Webpack的代码切割）
- 使用CDN加速，将通用的库从vendor进行抽离
- Nginx的gzip压缩
- Vue异步组件
- 服务端渲染SSR
- 如果使用了一些UI库，采用按需加载
- Webpack开启gzip压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker缓存文件处理
- 使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功
能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导
航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载
好，优化页面打开速度）

### 浏览器渲染过程
> 1. 处理 HTML 标记并构建 DOM 树。
> 2. 处理 CSS 标记并构建 CSSOM 树。
> 3. 将 DOM 与 CSSOM 合并成一个渲染树。
> 4. 根据渲染树来布局，以计算每个节点的几何信息。
> 5. 将各个节点绘制到屏幕上。
- 从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：
> 1. DNS 查询
> 2. TCP 连接
> 3. HTTP 请求即响应
> 4. 服务器响应
> 5. 客户端渲染
- defer async 
> defer 属性表示延迟执行引入的 JavaScript
> defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞
HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。
> async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经
加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发
之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句
话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定
在 load 触发之前执行

### 何时触发回流和重绘
> 1. 添加或删除可见的DOM元素
> 2. 元素的位置发生变化
> 3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
> 4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
> 5. 页面一开始渲染的时候（这肯定避免不了）
> 6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

### 如何避免触发回流和重绘
- CSS
> 避免使用table布局。
> 尽可能在DOM树的最末端改变class。
> 避免设置多层内联样式。
> 将动画效果应用到position属性为absolute或fixed的元素上
> 避免使用CSS表达式（例如：calc()）
> CSS3硬件加速（GPU加速） transform
- JavaScript
> 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并
一次性更改class属性
> 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最
后再把它添加到文档中
> 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在
display属性为none的元素上进行的DOM操作不会引发回流和重绘
> 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓
存起来
> 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续
元素频繁回流

### 从 8 道面试题看浏览器渲染过程与性能优化
[从8道面试题看浏览器渲染过程与性能优化]https://juejin.im/post/5e143104e51d45414a4715f7