# 输入网址到浏览器渲染过程
```html
 <img src="/browser/browser.jpg" />
```
## 0.9 看浏览器缓存
## 1. DNS解析
- DNS解析IP地址，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址，没有的话，浏览器会发出一个 DNS请求到本地DNS服务器，此过程是递归的方式进行查询，没有再到根服务器，再没有到域服务器找到域名的解析服务器的地址。这种过程是迭代的过程。本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系

## 2. http请求头，建立TCP连接，浏览器进程切换
 - http是超文本传输协议，本质就是 tcp/ip请求
 - 浏览器进程 -> 网络进程

## 3. 服务器处理请求

## 4. 四次挥手，http响应头
 - 网络进程 -> 浏览器进程 -> GPU渲染进程

## 5. 渲染HTML页面，浏览器进程切换
 - GPU渲染进程 -> 浏览器进程

### 浏览器渲染过程
1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。
6. 浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面
- 从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：
> 1. DNS 查询
> 2. TCP 连接
> 3. HTTP 请求即响应
> 4. 服务器响应
> 5. 客户端渲染

### 首屏加载优化
- Vue-Router路由懒加载（利用Webpack的代码切割）
- 使用CDN加速，将通用的库从vendor进行抽离
- Nginx的gzip压缩
- Vue异步组件
- 服务端渲染SSR
- 如果使用了一些UI库，采用按需加载
- Webpack开启gzip压缩
- 如果首屏为登录页，可以做成多入口
- Service Worker缓存文件处理
- 使用link标签的rel属性设置   prefetch（这段资源将会在未来某个导航或者功
能要用到，但是本资源的下载顺序权重比较低，prefetch通常用于加速下一次导
航）、preload（preload将会把资源得下载顺序权重提高，使得关键数据提前下载
好，优化页面打开速度）

### 何时触发回流和重绘
- 回流必将引起重绘，重绘不一定会引起回流。
> 1. 添加或删除可见的DOM元素
> 2. 元素的位置发生变化
> 3. 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
> 4. 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
> 5. 页面一开始渲染的时候（这肯定避免不了）
> 6. 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

### 如何避免触发回流和重绘
- CSS
> 避免使用table布局。
> 尽可能在DOM树的最末端改变class。
> 避免设置多层内联样式。
> 将动画效果应用到position属性为absolute或fixed的元素上
> 避免使用CSS表达式（例如：calc()）
> CSS3硬件加速（GPU加速） transform
- JavaScript
> 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并
一次性更改class属性
> 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最
后再把它添加到文档中
> 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在
display属性为none的元素上进行的DOM操作不会引发回流和重绘
> 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓
存起来
> 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续
元素频繁回流

### 回流重绘和Event loop有关
1. 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。
2. 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 requestAnimationFrame 回调
7. 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调

### CSS加载会造成阻塞吗
- css加载不会阻塞DOM树的解析
- css加载会阻塞DOM树的渲染
- css加载会阻塞**后面js**语句的执行

- 怎么判断页面是否加载完成
> onLoad 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。
> DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

- DOMContentLoaded
 - 如果页面中同时存在css和js，并且存在js在css后面，则DOMContentLoaded事件会在css加载完后才执行。
 - 其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。

### 为什么 Javascript 要是单线程的 ?
这是因为 Javascript 这门脚本语言诞生的使命所致!JavaScript 为处理页面中用户的交互,以及操作 DOM 树、CSS 样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。
如果 JavaScript 是多线程的方式来操作这些 UI DOM,则可能出现 UI 操作的冲突。
如果 Javascript 是多线程的话,在多线程的交互下,处于 UI 中的 DOM 节点就可能成为一个临界资源,
假设存在两个线程同时操作一个 DOM,一个负责修改一个负责删除,那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。
当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性,Javascript 在最初就选择了单线程执行。

### 为什么 JS 阻塞页面加载 ?
由于 JavaScript 是可操纵 DOM 的,如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行）,那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果,浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系。
当 JavaScript 引擎执行时 GUI 线程会被挂起,GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。
从上面我们可以推理出,由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系,
当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个队列中,直到 JS 程序执行完成,才会接着执行。
因此如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。
- js的加载会阻塞DOM树的解析

### 渲染过程中遇到JS文件怎么处理？
JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。

JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。

原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。

- 这是什么情况？

这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。

### DOMContentLoaded 与 load 的区别 ?
当 DOMContentLoaded 事件触发时,仅当 DOM 解析完成后,不包括样式表,图片。我们前面提到 CSS 加载会阻塞 Dom 的渲染和后面 js 的执行,js 会阻塞 Dom 解析,所以我们可以得到结论:当文档中没有脚本时,浏览器解析完文档便能触发 DOMContentLoaded 事件。如果文档中包含脚本,则脚本会阻塞文档的解析,而脚本需要等 CSSOM 构建完成才能执行。在任何情况下,DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。
当 onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。
DOMContentLoaded -> load。

### defer 和 async 的区别 ?
当浏览器碰到 script 脚本的时候 :
1. <script src="script.js">
没有 defer 或 async,浏览器会立即加载并执行指定的脚本,“立即”指的是在渲染该 script 标签之下的文档元素之前,也就是说不等待后续载入的文档元素,读到就加载并执行。
2. <script async src="script.js">
有 async,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
3. <script defer src="myscript.js">
有 defer,加载后续文档元素的过程将和 script.js 的加载并行进行（异步）,但是 script.js 的执行要在所有元素解析完成之后,DOMContentLoaded 事件触发之前完成。
从实用角度来说,首先把所有脚本都丢到 </body> 之前是最佳实践,因为对于旧浏览器来说这是唯一的优化选择,此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。

接着,我们来看一张图:
![](https://user-gold-cdn.xitu.io/2020/1/7/16f7edfaa3e8c6ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

蓝色线代表网络读取,红色线代表执行时间,这俩都是针对脚本的。绿色线代表 HTML 解析。
因此,我们可以得出结论:
1. defer 和 async 在网络读取（下载）这块儿是一样的,都是异步的（相较于 HTML 解析）
2. 它俩的差别在于脚本下载完之后何时执行,显然 defer 是最接近我们对于应用脚本加载和执行的要求的
3. 关于 defer,此图未尽之处在于它是按照加载顺序执行脚本的,这一点要善加利用
4. async 则是一个乱序执行的主,反正对它来说脚本的加载和执行是紧紧挨着的,所以不管你声明的顺序如何,只要它加载完了就会立刻执行
5. 仔细想想,async 对于应用脚本的用处不大,因为它完全不考虑依赖（哪怕是最低级的顺序执行）,不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的

### JS 什么时候解析？

```js
<script>
渲染过程中，如果遇到 JS 就停止渲染，执行 JS 代码。
如果 JS 需要操作CSSOM，则会先让CSSOM构建完，再执行JS，最后构建DOM

<script async>
异步执行引入的 JavaScript，加载完成后就执行 JS，阻塞DOM

<script defer>
延迟执行。载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。
```


### 什么是 CRP,即关键渲染路径(Critical Rendering Path)? 如何优化 ?
关键渲染路径是浏览器将 HTML CSS JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤。也就是我们上面说的浏览器渲染流程。
为尽快完成首次渲染,我们需要最大限度减小以下三种可变因素:
- 关键资源的数量: 可能阻止网页首次渲染的资源。
- 关键路径长度: 获取所有关键资源所需的往返次数或总时间。
- 关键字节: 实现网页首次渲染所需的总字节数,等同于所有关键资源传送文件大小的总和。
1. 优化 DOM
 - 删除不必要的代码和注释包括空格,尽量做到最小化文件。
 - 可以利用 GZIP 压缩文件
 - 结合 HTTP 缓存文件
2. 优化 CSSOM
  缩小、压缩以及缓存同样重要,对于 CSSOM 我们前面重点提过了它会阻止页面呈现,因此我们可以从这方面考虑去优化
 - 减少关键 CSS 元素数量
 - 当我们声明样式表时,请密切关注媒体查询的类型,它们极大地影响了 CRP 的性能 
3. 优化 JavaScript
当浏览器遇到 script 标记时,会阻止解析器继续操作,直到 CSSOM 构建完毕,JavaScript 才会运行并继续完成 DOM 构建过程。
 - async: 当我们在 script 标记添加 async 属性以后,浏览器遇到这个 script 标记时会继续解析 DOM,同时脚本也不会被 CSSOM 阻止,即不会阻止 CRP。
 - defer: 与 async 的区别在于,脚本需要等到文档解析后（ DOMContentLoaded 事件前）执行,而 async 允许脚本在文档解析时位于后台运行（两者下载的过程不会阻塞 DOM,但执行会）。
 - 当我们的脚本不会修改 DOM 或 CSSOM 时,推荐使用 async 。
 - 预加载 —— preload & prefetch 。
 - DNS 预解析 —— dns-prefetch 。

## 6. 发送HTTP请求接口数据，同源策略，浏览器安全，跨域

### 同源策略
域名，协议，端口
只要有一个不同就会产生跨域问题

### HTTPS与HTTP的一些区别
- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之
上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者
是443
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题

[https加密与解密]https://www.cnblogs.com/magic-sea/p/11348944.html

### HTTP1.0 和 HTTP1.1的一些区别
1. 缓存处理
> 在**HTTP1.0**中主要使用header里的If-Modified-Since,Expires来做为缓存判断
的标准，**HTTP1.1**则引入了更多的缓存控制策略例如Entity tag，
If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控
制缓存策略
2. 带宽优化及网络连接的使用
> HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，
而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引
入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial 
Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
3. 错误通知的管理
> 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与
资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除
4. Host头处理
> 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL
并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器
上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地
址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host
头域会报告一个错误（400 Bad Request）
5. 长连接
> HTTP 1.1支持长连接（PersistentConnection）和请求的流水线
（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立
和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一
定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

### HTTP2.0和HTTP1.X相比的新特性
1. 新的二进制格式
> HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现
形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组
合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
2. 多路复用（处理成帧数据）
> 即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一
个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在
一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面
3. header压缩
> HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder
来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免
了重复header的传输，又减小了需要传输的大小
4. 服务端推送
> server push功能 服务端推送能把客户端所需要的资源伴随着index.html一起发
送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操
作，所以静态资源通过服务端推送的方式可以极大地提升速度

### HTTP2.0和HTTP3.0的区别
- HTTP2.0虽然解决了应⽤层⾯的队头阻塞问题，当系统达到了2%的丢包率时，HTTP/1.1的传输效率反⽽⽐HTTP/2表现得更好，HTTP3.0是对UDP的优化

### HTTP 缓存
- 缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，**强缓存的优先级高于协商缓存**。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

- 强缓存
 - 强缓存返回的状态码是 200
 - Expires: 在 http1.0 中使用，表示资源失效的具体时间点 Expires:Sat, 09 Jun 2018 08:13:56 GMT，使用的是绝对时间，若是访问器和本地时间不一致，可能就会出现问题，在现在 http1.1中换成了 max-age ，为了兼容也可以加上。
 - Cache-control： 指定指令来实现缓存机制
  1. private：客户端可以缓存
  2. public：客户端和代理服务器都可以缓存
  3. max-age=t：缓存内容将在t秒后失效
  4. no-cache：需要使用协商缓存来验证缓存数据
  5. no-store：所有内容都不会缓存

- 协商缓存
 - 协商缓存，关键在于协商，在使用本地缓存之前，需要先跟服务器做个对比，服务器告知你的资源可用，是最新的，那就可以直接取本地资源，反之，服务器返回最新的资源给客户端，客户端收到后更新本地资源
  1. 若本地资源是最新的，那么返回 304 （考点!）
  2. 若比对后，需要从服务器获取最新资源，那就是正常的 200
 - Last-modified If-Modified-Since
  - 采用资源最后修改时间来判断，单位精度秒
  1. Last-Modified：服务器资源的最新更新时间 Tue, 14 Jan 2020 09:18:29 GMT
  2. If-Modified-Since：发起协商，把本地记录的文件更新时间传给服务器，服务器进行判断比较
  3. 这个判断方式是 **http1.0** 的产物，因为时间精度是秒，若文件的更新频率在秒级以内，就会出现文件不一致。
 - ETag If-None-Match
  - 为了解决上面的那个问题， **http1.1** 加了这组标记
  1. ETag：服务器根据内容生成唯一的字符串标识
  2. If-None-Match：发起协商，把本地记录的 hash 标识传给服务器，服务器进行判断比较

### 强制缓存 (也叫强缓存)
### 制缓存直接减少请求数，是提升最大的缓存策略。 它的优化覆盖了请求、处理、响应三个阶段
#### 可以造成强制缓存的字段是 Cache-control 和 Expires。

- Expires：
 - HTTP1.0
 - 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自信修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。
 - 写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效


- Cache-control
 - HTTP1.1
 - 优先级高
 - max-age：即最大有效时间
  must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
  no-cache：虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。
  no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
  public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
  private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。


对比缓存 (协商缓存)
对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。

Last-Modified & If-Modified-Since

服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间
浏览器将这个值和内容一起记录在缓存数据库中。
下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段
服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。
如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。


Etag & If-None-Match

Etag 的优先级高于 Last-Modified
Etag 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。
之后的流程和 Last-Modified 一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 hash，把 If-Modified-Since 变成了 If-None-Match。
服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。

### HTTP常见的请求头
- Request Headers
Accept: 浏览器端接受的格式
Accept-Encoding: 浏览器接收的编码方式
Accept-Language: 浏览器接收的语言，用于服务器端判断多语言
Cache-Control: 控制缓存的时效性
Content-Type：客户端发送出去实体内容的类型
Connention: 连接方式，如果是keep-alive,且服务端支持。则会复用连接
Host: HTTP访问使用的域名
If-Modified-Since: 上次访问时的更改时间，如果服务端认为此时间后自己没有更新，则会给出304响应
If-None-Match: 次访问时使用的E-Tag, 通常是页面的信息摘要，这个比更改时间更准确一些。
User-Agent: 客户端标识。
Cookie: 客户端存储的cookie字符串。
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)

- Response Header
Cache-Control: 缓存控制，用于通知各级缓存保存的时间，例如max-age...
Connection: 连接类型，Keep-Alive表示复用连接。
Content-Encoding: 内容编码方式。通常是gzip。
Content-Length: 内容的长度，有利于浏览器判断内容是否已经结束。
Content-Type: 内容类型，所有请求网页都是text/html.
Date: 当前的服务器日期
Etag: 页面的信息摘要，用于判断是否需要重新到服务端取回页面
Expires: 过期时间，用于判断下次请求是否需要到服务端取回页面。
Keep-Alive: 保持连接不断时需要的一些信息，如timeout=5,max=10.
Last-Modified: 页面上次修改的时间。
Server: 服务端软件的类型。
Set-cookie: 设置cookie，可以存在多个。

### 三次握手
- 三次握手的作用
1. 确认双方的接收与发送能力是否正常
2. 指定自己的初始化序列号，为后面的可靠传送做准备。
3. 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。
- 三次握手的过程
1. 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。
2. 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
3. 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
4. 服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。
- 三次握手过程中可以携带数据吗
 - 第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。因为第三次客户端已经知道服务器能正常接发数据了

### 四次挥手
- 刚开始双方都处于 establised 状态
1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。
2. 的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。
3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5. 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态
- 为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。
  - 要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

### 为什么握手三次挥手四次
　这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送

### get和post请求的区别
1. GET在浏览器回退时是无害的，而POST会再次提交请求。 
2. GET产生的URL地址可以被Bookmark，而POST不可以。 
3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。 
4. GET请求只能进行url编码，而POST支持多种编码方式。 
5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 
6. GET请求在URL中传送的参数是有长度限制的，而POST么有。 
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 
7. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 
8. GET参数通过URL传递，POST放在Request body中。
9. GET产生一个TCP数据包;POST产生两个TCP数据包。
 - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);
 - 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。

### session和cookie
- cookie存在浏览器里的，可以设置存储时间，有域名的限制，服务端客户端都可以写入，每次请求都会带上cookie
- 缺点：cookie 容易被盗取，获取用户信息

- session存在服务端
- 缺点：用户量太大存的session太多，消耗服务器资源
- 拓展：一般session都存在当前服务器上，然后后端不止一台服务器，然后登陆信息的session太多的话，就需要通过反向代理，然后又通过轮询，ip哈希

### 















# 浏览器分别有哪些进程（4个）
- Browser进程：浏览器的主进程（负责协调、主控），只有一个
  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
  - 网络资源的管理，下载等
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU进程：最多一个，用于3D绘制
- 浏览器内核（渲染进程）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 多线程和多进程
- 多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰
- 多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。
- 以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁

### 并行和并发的区别
- 普通解释：
 - 并发：交替做不同事情的能力
 - 并行：同时做不同事情的能力
- 专业术语：
 - 并发：不同的代码块交替执行
 - 并行：不同的代码块同时执行

- 并发和并行的意义：
 - 并发和并行都可以处理“多任务”，二者的主要区别在于是否是“同时进行”多个的任务

### node进程接受多个请求是并行还是并发
- 单线程解决高并发的思路就是采用非阻塞，异步编程的思想。简单概括就是当遇到非常耗时的IO操作时，采用非阻塞的方式，继续执行后面的代码，并且进入事件循环，当IO操作完成时，程序会被通知IO操作已经完成。主要运用JavaScript的回调函数来实现
- 多线程虽然也能解决高并发，但是是以建立多个线程来实现，其缺点是当遇到耗时的IO操作时，当前线程会被阻塞，并且把cpu的控制权交给其他线程，这样带来的问题就是要非常频繁的进行线程的上下文切换。

### JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？
- 进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是 CPU 调度的最小单位（是建立在进程基础上的一次程序运行单位）
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；

### 浏览器渲染进程（浏览器内核）
> 简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。

> 浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

  1. GUI 渲染线程
  2. JavaScript 引擎线程
  3. 定时触发器线程
  4. 事件触发线程 
  5. 异步 http 请求线程
#### 1. GUI 渲染线程
- 主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。
- 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
- 注意, GUI 渲染线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。

#### 2. JS 引擎线程
- 该线程当然是主要负责处理 JavaScript 脚本，执行代码。
- 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。
- 当然，JS 引擎线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。

#### 3. 定时器触发线程
- 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
- 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中,等待 JS 引擎空闲后执行）
- 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。

#### 4. 事件触发线程
- 主要负责将准备好的事件交给 JS 引擎线程执行。
比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。

#### 5. 异步 http 请求线程
- 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。
- 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。

### 浏览器部分概念解析
- PC 时代为了突破浏览器的域名并发限制。有了域名发散。
- 浏览器有并发限制，是为了防止DDOS攻击。
1. 域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。
2. 域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。
3. 域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。

### 五层因特尔协议栈其实就是：
 1. 应用层(dns,http) DNS解析成IP并发送http请求 
 2. 传输层(tcp,udp) 建立tcp连接（三次握手） 
 3. 网络层(IP,ARP) IP寻址 
 4. 数据链路层(PPP) 封装成帧 
 5. 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
- OSI七层框架： 物理层、 数据链路层、 网络层、 传输层、 会话层、 表示层、 应用层。
 - 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
 - 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程


### 各种获得宽高的方式
```
获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width
获取屏幕工作区域的高度和宽度（去掉状态栏）：window.screen.availHeight/availWidth
网页全文的高度和宽度：document.body.scrollHeight/Width
滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft
网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth
网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth
```



### 什么是渲染层合并 (Composite) ?
渲染层合并,对于页面中 DOM 元素的绘制(Paint)是在多个层上进行的。
在每个层上完成绘制过程之后,浏览器会将绘制的位图发送给 GPU 绘制到屏幕上,将所有层按照合理的顺序合并成一个图层,然后在屏幕上呈现。

### Node 与浏览器的 Event Loop 差异
- Node 端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行

### 浏览器性能监控
- 使用 performance.timing 这个api就可以获取到绝大部分性能相关的数据

### 垃圾回收机制

[http状态码]https://www.cnblogs.com/xflonga/p/9368993.html