# 浏览器分别有哪些进程（4个）
- Browser进程：浏览器的主进程（负责协调、主控），只有一个
  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
  - 网络资源的管理，下载等
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU进程：最多一个，用于3D绘制
- 浏览器内核（渲染进程）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）

![](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 多线程和多进程
- 多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰
- 多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。
- 以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁

### 并行和并发的区别
- 普通解释：
 - 并发：交替做不同事情的能力
 - 并行：同时做不同事情的能力
- 专业术语：
 - 并发：不同的代码块交替执行
 - 并行：不同的代码块同时执行

- 并发和并行的意义：
 - 并发和并行都可以处理“多任务”，二者的主要区别在于是否是“同时进行”多个的任务

### node进程接受多个请求是并行还是并发
- 单线程解决高并发的思路就是采用非阻塞，异步编程的思想。简单概括就是当遇到非常耗时的IO操作时，采用非阻塞的方式，继续执行后面的代码，并且进入事件循环，当IO操作完成时，程序会被通知IO操作已经完成。主要运用JavaScript的回调函数来实现
- 多线程虽然也能解决高并发，但是是以建立多个线程来实现，其缺点是当遇到耗时的IO操作时，当前线程会被阻塞，并且把cpu的控制权交给其他线程，这样带来的问题就是要非常频繁的进行线程的上下文切换。

### JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？
- `进程是 CPU 资源分配`的最小单位（是能拥有资源和独立运行的最小单位）；`线程是 CPU 调度`的最小单位（是建立在进程基础上的一次程序运行单位）
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；

### 浏览器渲染进程（浏览器内核）
> 简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。

> 浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

  1. GUI 渲染线程
  2. JavaScript 引擎线程
  3. 定时触发器线程
  4. 事件触发线程 
  5. 异步 http 请求线程
#### 1. GUI 渲染线程
- 主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。
- 当界面需要重绘或者由于某种操作引发回流时，将执行该线程。
- 注意, GUI 渲染线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。

#### 2. JS 引擎线程
- 该线程当然是主要负责处理 JavaScript 脚本，执行代码。
- 也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。
- 当然，JS 引擎线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。

#### 3. 定时器触发线程
- 负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。
- 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中,等待 JS 引擎空闲后执行）
- 主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。

#### 4. 事件触发线程
- 主要负责将准备好的事件交给 JS 引擎线程执行。
比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。

#### 5. 异步 http 请求线程
- 负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。
- 主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行。

### 浏览器部分概念解析
- PC 时代为了突破浏览器的域名并发限制。有了域名发散。
- 浏览器有并发限制，是为了防止DDOS攻击。
1. 域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。
2. 域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。
3. 域名发散是pc端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。

### 五层因特尔协议栈其实就是：
 1. 应用层(dns,http) DNS解析成IP并发送http请求 
 2. 传输层(tcp,udp) 建立tcp连接（三次握手） 
 3. 网络层(IP,ARP) IP寻址 
 4. 数据链路层(PPP) 封装成帧 
 5. 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
- OSI七层框架： 物理层、 数据链路层、 网络层、 传输层、 会话层、 表示层、 应用层。
 - 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
 - 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程



### 什么是渲染层合并 (Composite) ?
渲染层合并,对于页面中 DOM 元素的绘制(Paint)是在多个层上进行的。
在每个层上完成绘制过程之后,浏览器会将绘制的位图发送给 GPU 绘制到屏幕上,将所有层按照合理的顺序合并成一个图层,然后在屏幕上呈现。

### Node 与浏览器的 Event Loop 差异
- Node 端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行

### 浏览器性能监控
- 使用 performance.timing 这个api就可以获取到绝大部分性能相关的数据

### 垃圾回收机制

[http状态码]https://www.cnblogs.com/xflonga/p/9368993.html
### http状态码
响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)

201 `服务器依照客户端的请求创建了一个新资源时，发送此响应代码`
202 客户端的请求无法或将不被实时处理。请求稍后会被处理。请求看上去是合法的，但在实际处理它时有出现问题的可能
203 有些响应报头并非来自该服务器--他们可能是从客户端先前发送的一个请求里复制的，或者从第三方得到的
204 `客户端请求的资源存在，但其表示是空的`
205 与204类似， 它表明客户端应重置数据源的视图或数据结构
206 对部分GET请求的响应。部分GET请求常用于大型二进制文件的断点续传

3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。
300 被请求的资源在服务器端存在多个表示，而服务器不知道客户端想要的是哪一个表示时，发送这个响应代码
301 服务器知道客户端试图访问的是哪个资源，但它不喜欢客户端用当前URI来请求该资源`（永久重定向）`
302 不要发送302.除非你知道正在与一个不能理解303或307`（临时重定向）`
303 `请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的URI`
304 `跟204("No Content")类似：响应实体主体都必须为空。但204用于没有主体数据的情况，而304用于有主体数据，但客户端已拥有该数据，没必要重复发送的情况`（资源未被修改）
305 告诉客户端它需要再发一次请求，但这次要通过一个HTTP代理发送，而不是直接发送给服务器
306 `响应代码没有在HTTP标准中定义过   undefined`
307 请求还没有被处理，因为所请求的资源不在本地：它在另一个URI处

4XX系列响应代码表明：客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正
400 客户端发送了一个错误的请求，比如请求中的参数不符合要求
401 `客户端发送了一个未经授权的请求`
402 HTTP标准没有对该响应的其他方面作任何定义 
403 没有权限
404 
405 客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问
406 当客户端对表示有太多要求，以至于服务器无法提供满足要求的表示，服务器可以发送这个响应代码
407 只有HTTP代理会发送这个响应代码。它跟401类似，唯一区别在于：这里不是无权访问web服务，而是无权访问代理。跟401一样，可能是因为客户端没有提供证书，也可能是客户端提供的证书不正确或不充分。
408 HTTP客户端与服务器建立链接后，却不发送任何请求（或从不发送表明请求结束的空白行），那么服务器最终应该发送一个408响应代码，并关闭此连接
409 `你请求的操作会导致服务器的资源处于一种不可能或不一致的状态。例如你试图修改某个用户的用户名，而修改后的用户名与其他存在的用户名冲突了`
410 这个响应代码跟404类似，但它提供的有用信息更多一些
...
417