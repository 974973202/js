### 正则表达式(Regular Expression)
> 其实就是一门工具，目的是为了字符串模式匹配，从而实现搜索和替换功能
- 特殊字符
> 匹配区间 | 正则表达式 | 记忆方式
> -|-|-
> 换行符 | \n | new line
> 换页符 | \f | form feed
> 回车符 | \r | return
> 空白符 | \s | space
> 制表符 | \t | tab
> 垂直制表符 | \v | vertical tab
> 回退符 | [\b] | backspace,之所以使用[]符号是避免和\b重复

> 除了换行符之外的任何字符 | . | 句号,除了句子结束符
> -|-|-
> 单个数字, [0-9] | \d | digit
> 除了[0-9] | \D | not digit
> 包括下划线在内的单个字符，[A-Za-z0-9_] | \w | word
> 非单字字符 | \W | not word
> 匹配空白字符,包括空格、制表符、换页符和换行符 | \s | space
> 匹配非空白字符 | \S | not space

- 元字符 **?** 代表了匹配一个字符或0个字符。设想一下，如果你要匹配color和colour这
两个单词，就需要同时保证u这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样
的：/colou?r/ (0|1)

- 元字符 **\*** 用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串 (>=0)

- 元字符 **+** 适用于要匹配同个字符出现1次或多次的情况 (>=1)

- 元字符 **{** 和 **}** 用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就
使用/a{3}/这个正则，或者说'a'我想匹配至少两次就是用/a{2,}/这个正则
> {x}: x次
> {min, max}： 介于min次到max次之间
> {min, }: 至少min次
> {0, max}： 至多max次

> 边界和标志 | 正则表达式 | 记忆方式
> -|-|-
> 单词边界 | \b | boundary
> 非单词边界 | \B | not boundary
> 字符串开头 | ^ | 小头尖尖那么大个
> 字符串结尾 | $ | 终结者，美国科幻电影，美元符$
> 多行模式 | m标志 | multiple of lines
> 忽略大小写 | i标志 | ignore case, case-insensitive
> 全局模式 | g标志 | global

### 分组
```
所有以 **(** 和 **)**元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达
式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组
是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式
```

### 回溯引用
```
所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你
可以把它想象成是变量，回溯引用的语法像\1,\2,....,其中\1表示引用的第一个子表达式，\2
表示引用的第二个子表达式，以此类推。而\0则表示整个表达式
```

### 前向查找
```
前向查找(lookahead)是用来限制后缀的。凡是以(?=regex)包含的子表达式在匹配过程中都会
用来限制前面的表达式的匹配。例如happy happily这两个单词，我想获得以happ开头的副
词，那么就可以使用happ(?=ily)来匹配。如果我想过滤所有以happ开头的副词，那么也可以采
用负前向查找的正则happ(?!ily)，就会匹配到happy单词的happ前缀
```

### 后向查找
```
介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找
(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规
则的字串。举个简单的例子： apple和people都包含ple这个后缀，那么如果我只想找到apple
的ple，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定ple这个单词了
```
```
/(?<=app)ple/
```
```
其中(?<=regex)的语法就是我们这里要介绍的后向查找。regex指代的子表达式会作为限制项进
行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用(?<!regex) 语
法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在
上面的例子中，如果想要查找apple的ple也可以这么写成/(?<!peo)ple。
需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用
到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转
回来。看一个简单的例子
```
```
// 比如我想替换apple的ple为ply
var str = 'apple people';
str.split('').reverse().join('').replace(/elp(?=pa)/, 'ylp').split('').reverse().join('');
```

> 回溯查找 | 正则 | 记忆方式
> -|-|-
> 引用 | \0,\1,\2 和 $0, $1, $2 | 转义+数字
> 非捕获组 | (?:) | 引用表达式(()), 本身不被消费(?),引用(:)
> 前向查找 | (?=) | 引用子表达式(())，本身不被消费(?), 正向的查找(=)
> 前向负查找 | (?!) | 引用子表达式(())，本身不被消费(?), 负向的查找(!)
> 后向查找 | (?<=) | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=)
> 后向负查找 | (?<!) | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!)

### 逻辑处理
> 计算机科学就是一门包含逻辑的科学。
> 让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。
> 在正则里面，默认的正则规则都是与的关系所以这里不讨论。
> 而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。
> 在字符匹配的时候，需要使用^这个元字符。
> 在这里要着重记忆一下：只有在 **[** 和 **]**内部使用的^才表示非的关系。
> 子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式(?!regex)或后向负查找子表达式(?<!regex)。
> 或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用(a|b)这样的子表达式。

> 逻辑关系 | 正则元字符
> -|-
> 与 | 无
> 非 | [^regex]和!
> 或 | |
